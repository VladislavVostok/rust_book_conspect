/*
    8.      Общие коллекции (Common Collections)
    8.1.    Хранение списков значений в векторах (Storing Lists of Values with Vectors)
*/

// В отличии от массива и кортежа, данные коллекций хранятся в куче, 
// это значит, что размер коллекции может быть неизвестен в момент компиляции программы.

// Виды коллекций:
// Вектор (vector) - позволяет сохранять различное количество последовательно хранящихся значений
// Строка (string) - это последовательность символов.
// Хеш-таблица (hash map) - коллекция которая позволяет хранить перечень ассоциаций значения с ключом (ключ:значение). 
// Является конкретной реализацией более общей структуры данных нахываемой map.
// https://doc.rust-lang.org/std/collections/index.html  -  тут все коллекции


fn main() {

    /* Создание нового вектора */

    let v: Vec<i32> = Vec::new();   // Создание нового пустого вектора. Вектор этот обобщённый тип Vec<T> и при создании пустого вектора нужно указывать тип T. 
    let v = vec![1,2,3];            // С помощью макроса vec! можно создать вектор, в котором изначально задаются значения для хранения. 
                                    // Т.к. по умолчанию тип данных у целых чисел i32, то вектор будет хранить по умолчанию i32.

    /* Изменение вектора */
    let mut v = Vec::new();     // Т.к. мы в изменяемую mut переменную v методом push передаём числа, то можно не указывать явно тип переменной v.
    v.push(5);                  // передаём вектору значение i32 целое число.
    v.push(6);
    v.push(7);
    v.push(8);

    /* Чтение данных вектора */
    let v = vec![1, 2, 3, 4, 5];
    let third: &i32 = &v[2];                    // Обращаться к элементам вектора можно использую индексацию
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(2);          // Или через метод get(), в который в качестве аргумента передаём индекс элемента.
    match third{
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }

    let v = vec![1, 2, 3, 4, 5];
    //let does_not_exist = &v[100];     // Компилятор вызывает панику, т.к. пытаемся получить ссылку на элемент, который не существует.
    let does_not_exist = v.get(100);    // Здесь метод get() оборачивает в перечисление Option<T> в котором возвращается Some(T) или если значения нет None.

    let mut v = vec![1,2,3,4,5];
    //let first = &v[0];                  // Будет паника так как, после v.push() может произойти смена адреса первого элемента. 
                                        // Так как в векторе значения храняться друг за другом и если не будет хватать места в памяти,
                                        // то компилятор будет искать место в памяти и копировать туда вектор, следовательно и поменяется адрес первого элемента
    v.push(6);
    // println!("The first element is: {first}");

    /*
        error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
        --> src\main.rs:49:5
        |
        48 |     let first = &v[0];
        |                  - immutable borrow occurs here
        49 |     v.push(6);
        |     ^^^^^^^^^ mutable borrow occurs here
        50 |     println!("The first element is: {first}");
        |                                      ----- immutable borrow later used here
    
    
        Эта ошибка возникает из-за особенности того, как работают векторы: 
        поскольку векторы размещают значения в памяти друг за другом, 
        добавление нового элемента в конец вектора может потребовать выделения 
        новой памяти и копирования старых элементов в новое пространство, если 
        нет достаточного места, чтобы разместить все элементы друг за другом там, 
        где в данный момент хранится вектор. В этом случае ссылка на первый элемент 
        будет указывать на освобождённую память. Правила заимствования предотвращают 
        попадание программ в такую ситуацию.
    */

    /* Перебор значений в векторе */
    // Для доступа к каждому элементу вектора по очереди, мы итерируем все элементы,
    // вместо использования индексов для доступа к одному за раз.

    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }

    // Мы также можем итерировать изменяемые ссылки на каждый элемент изменяемого вектора, 
    // чтобы вносить изменения во все элементы. 

    let mut v = vec![100, 32, 57];
    for i in &mut v{
        *i += 50;           // Для того чтобы изменить значение нам нужно применить к ссылке оператор * (разыменование)
    }

    /* Ссылка на вектор, содержащийся в цикле for, предотвращает одновременную модификацию всего вектора. */

    // Вывод на экран изменяемости значений вектора в предыдущем примере.
    for i in &v {
        println!("{i}");
    }

    /* Использование перечислений для хранения множества разных типов */

    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    /* 
        Векторы могут хранить значения только одинакового типа. Это может быть неудобно; определённо могут быть случаи когда 
        надо хранить список элементов разных типов. К счастью, варианты перечисления определены для одного и того же типа перечисления, 
        поэтому, когда нам нужен один тип для представления элементов разных типов, мы можем определить и использовать перечисление! 

        Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, 
        некоторые числа с плавающей точкой, а другие - строковые значения. Можно определить перечисление, варианты которого будут 
        содержать разные типы значений и тогда все варианты перечисления будут считаться одним и тем же типом: типом самого перечисления. 
        Затем мы можем создать вектор для хранения этого перечисления и, в конечном счёте, для хранения различных типов.

        Если вы не знаете исчерпывающий набор типов, которые программа получит во время выполнения для хранения в векторе, 
        то техника использования перечисления не сработает. Вместо этого вы можете использовать типаж-объект, 
    */
    let row = vec![SpreadsheetCell::Int(3), SpreadsheetCell::Float(10.12), SpreadsheetCell::Text(String::from("blue")),];


    /* Удаление элементов из вектора */
    {
        let v = vec![1, 2, 3, 4];
    }   // Покидая область видимости память занятая вектором освобождается, подобно структурам.

    /* 
        Когда вектор удаляется, всё его содержимое также удаляется: удаление вектора означает и удаление значений, которые он содержит. 
        Средство проверки заимствования гарантирует, что любые ссылки на содержимое вектора используются только тогда, когда сам вектор действителен. 
    */


    /* 
        ВАЖНАЯ ИНФА
        https://doc.rust-lang.org/std/vec/struct.Vec.html
    */
}
