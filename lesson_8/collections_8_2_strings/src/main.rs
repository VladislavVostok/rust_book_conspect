/*
    8.      Общие коллекции (Common Collections)
    8.2.    Хранение закодированного текста UTF-8 в строках (Storing UTF-8 Encoded Text with Strings)
*/

// Cтроки реализованы в виде набора байтов, плюс некоторые методы для обеспечения полезной функциональности, 
// когда эти байты интерпретируются как текст. ]

// В Rust есть только один строковый тип в ядре языка - срез строки str, обычно используемый в заимствованном виде как &str.
// срезах строк, string slices, которые являются ссылками на некоторые строковые данные в кодировке UTF-8. Например, 
// строковые литералы хранятся в двоичном файле программы и поэтому являются срезами строк.

// говоря о "строках" мы обычно имеют в виду типы String или строковые срезы &str, а не просто один из них.

// в стандартной библиотеке Rust, оба, и String и строковые срезы, кодируются в UTF-8.

fn main() {
    /* Создание новых строк */
    // Многие операции Vec<T>,  доступны в String, т.к. String фактически реализован как обёртка вокруг вектора байтов с некоторыми
    // дополнительными гарантиями, ограничениями и возможностями.
    // Например, функция new, создаёт новый экземпляр типа как в Vec<T>, так и в String.

    let data = "initial contents";
    let s = data.to_string();

    // так же метод работает с литеральным представлением
    let s = "initial contents".to_string();

    let s = String::from("initial contents");  // ещё один вариант создать String

    // строки хранятся в кодировке UTF-8, поэтому можно использовать любые правильно кодированные данные в них:
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");

    /* Обновление строковых данных */
    /* Присоединение к строке с помощью push_str и push */
    let mut s = String::from("foo");
    s.push_str("bar");                  //  метод push_str который добавит в исходное значение новый строковый срез
    println!("{s}");

    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);            // метод push_str не становиться владельцем переменной s2 по этому s2 выводится после выполнения данного метода.
    println!("s2 is {s2}");

    let mut s = String::from("lo");
    s.push('l');                        // Метод push принимает в качестве параметра один символ и добавляет его в конец модифицируемой строки.
    println!("s is {s}");

    /* Объединение строк с помощью оператора + или макроса format! */
    // Объединение строк с помощью + конкатинация
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2;    // оператор + соединяет первый объект и ссылку на второй объект. Первый объект уничтожается.
    //println!("s1 is {s1}");
    println!("s2 is {s2}");
    println!("s3 is {s3}");
    // Оператор + использует метод add, чья сигнатура выглядит примерно так:
    //    fn add(self, s: &str) -> String {
    // Компилятор может принудительно привести (coerce) аргумент типа &String к типу &str.
    // Когда мы вызываем метод add в Rust используется принудительное приведение (deref coercion), которое превращает &s2 в &s2[..]
    // Другими словами, это выглядит как будто код создаёт множество копий, но это не так; данная реализация более эффективна, чем копирование.

    // Если нужно объединить несколько строк, поведение оператора + становится громоздким:
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;

    // для объединения большого количества строк важно использовать макрос format!
    let s1 = String::from("tic");
    let s2 = String::from("tic");
    let s3 = String::from("tic");
    
    let s = format!("{s1}-{s2}-{s3}");
    // Так как format! использует ссылки на строки, то он не забирает во владение ни одного параметра и переменные остаются доступными.

    /* Индексирование в строках */

    // Rust не поддерживает индексацию для строк
    let s1 = String::from("hello");
    //let h = s1[0];            // данная операция запрещена компилятором ^^^^^ `String` cannot be indexed by `{integer}`

    /* Внутреннее представление */

    // В данном случае мы имеем один символ на один байт
    let hello = String::from("Hola");
    println!("{} is {} elments", hello, hello.len() );

    // В этом случае мы имеем один символ на два байта
    let hello = String::from("Здравствуйте");
    println!("{} is {} elments", hello, hello.len() );

    // Однако ответ Rust - 24, что равно числу байт, необходимых для кодирования «Здравствуйте» в UTF-8, так происходит, 
    // потому что каждое скалярное значение Unicode символа в этой строке занимает 2 байта памяти. Следовательно, индекс 
    // по байтам строки не всегда бы соответствовал действительному скалярному Unicode значению.
    let hello = "Здравствуйте";
    //let answer = &hello[0];

    // Каким должно быть значение переменной answer? Должно ли оно быть значением первой буквы З? При кодировке в UTF-8, 
    // первый байт значения З равен 208, а второй - 151, поэтому значение в answer на самом деле должно быть 208, но само 
    // по себе 208 не является действительным символом. Возвращение 208, скорее всего не то, что хотел бы получить пользователь: 
    // ведь он ожидает первую букву этой строки; тем не менее, это единственный байт данных, который в Rust доступен по индексу 0. 
    // Пользователи обычно не хотят получить значение байта, даже если строка содержит только латинские буквы: если &"hello"[0] было 
    // бы допустимым кодом, который вернул значение байта, то он вернул бы 104, а не h.

    // Таким образом, чтобы предотвратить возврат непредвиденного значения, вызывающего ошибки которые не могут быть сразу обнаружены, 
    // Rust просто не компилирует такой код и предотвращает недопонимание на ранних этапах процесса разработки.

    /* Байты, скалярные значения и кластеры графем! Боже мой! */

    // Ещё один момент, касающийся UTF-8, заключается в том, что на самом деле существует три способа рассмотрения строк с точки зрения Rust: 
    // как байты, как скалярные значения и как кластеры графем (самая близкая вещь к тому, что мы назвали бы буквами).

    // Если посмотреть на слово языка хинди «नमस्ते», написанное в транскрипции Devanagari, то оно хранится как вектор 
    // значений u8 который выглядит следующим образом:
    // [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,224, 165, 135]

    // Эти 18 байт являются именно тем, как компьютеры в конечном итоге сохранят в памяти эту строку. 
    // Если мы посмотрим на 18 байт как на скалярные Unicode значения, которые являются Rust типом char, то байты будут выглядеть так:
    // ['न', 'म', 'स', '्', 'त', 'े']

    // Здесь есть шесть значений типа char, но четвёртый и шестой являются не буквами: они диакритики, специальные обозначения которые 
    // не имеют смысла сами по себе. Наконец, если мы посмотрим на байты как на кластеры графем, то получим то, что человек назвал бы 
    // словом на хинди состоящем из четырёх букв:
    // ["न", "म", "स्", "ते"]

    // Rust предоставляет различные способы интерпретации необработанных строковых данных, которые компьютеры хранят так, чтобы каждой 
    // программе можно было выбрать необходимую интерпретацию, независимо от того, на каком человеческом языке представлены эти данные.

    // Последняя причина, по которой Rust не позволяет нам индексировать String для получения символов является то, что программисты 
    // ожидают, что операции индексирования всегда имеют постоянное время (O(1)) выполнения. Но невозможно гарантировать такую 
    // производительность для String, потому что Rust понадобилось бы пройтись по содержимому от начала до индекса, чтобы определить, 
    // сколько было действительных символов.

    /* Срезы строк */
    // Вместо индексации с помощью числового индекса [], можно использовать оператор диапазона [], 
    // в котором содержится указание на то, срез каких байтов надо делать
    let hello = "Здравствуйте";
    let s = &hello[0..4]; // здесь мы сделали срез первых 4 байтов, что в последствии на вывело фразу Зд
    println!("{s}");

    /* Методы для перебора строк */
    // Лучший способ работать с фрагментами строк - чётко указать, нужны ли вам символы или байты.
    for c in "Зд".chars(){           // метод chars() вернёт символы в Юникоде
        println!("{}", c);
    }

    for b in "Зд".bytes() {         // Метод bytes возвращает каждый байт, который может быть подходящим в другой предметной области:
        println!("{}",b);
    }

    // Но делая так, обязательно помните, что валидные скалярные Unicode значения могут состоять более чем из одного байта.

    // Извлечение кластеров графем из строк, как в случае с языком хинди, является сложным, поэтому эта функциональность не 
    // предусмотрена стандартной библиотекой. На crates.io есть доступные библиотеки, если Вам нужен данный функционал.

    /* Строки не так просты */
    // Подводя итог, становится ясно, что строки сложны. Различные языки программирования реализуют различные варианты того, 
    // как представить эту сложность для программиста. В Rust решили сделать правильную обработку данных String поведением по 
    // умолчанию для всех программ Rust, что означает, что программисты должны заранее продумать обработку UTF-8 данных. 
    // Этот компромисс раскрывает большую сложность строк, чем в других языках программирования, но это предотвращает от 
    // необходимости обрабатывать ошибки, связанные с не-ASCII символами которые могут появиться в ходе разработки позже.

    // Хорошая новость состоит в том что стандартная библиотека предлагает множество функциональных возможностей, построенных 
    // на основе типов String и &str, чтобы помочь правильно обрабатывать эти сложные ситуации. Обязательно ознакомьтесь с 
    // документацией для полезных методов, таких как contains для поиска в строке и replace для замены частей строки другой строкой.

}
