/*
    8.      Общие коллекции (Common Collections)
    8.2.    Хранение ключей со связанными значениями в HashMap (Storing Keys with Associated Values in Hash Maps)
*/

// Тип HashMap<K, V> хранит ключи типа K на значения типа V.
// Данная структура организует и хранит данные с помощью функции хеширования.

// Во множестве языков программирования реализована данная структура, но часто с разными наименованиями: 
// такими как hash, map, object, hash table, dictionary или ассоциативный массив.

fn main() {
    /* Создание новой хеш-карты */
    use std::collections::HashMap;                  // Подключает коллекцию HashMap в область видимости
    let mut scores = HashMap::new();                // Создаём пустой HashMap
    scores.insert(String::from("blue"), 10);        // С помощью метода insert вставляем данные ключ и значение в HashMap
    scores.insert(String::from("yellow"), 50);

    // Подобно векторам, хеш-карты хранят свои данные в куче. Здесь тип HashMap имеет в качестве типа ключей String, а в качестве типа значений тип i32. 
    // Как и векторы, HashMap однородны: все ключи должны иметь одинаковый тип и все значения должны иметь тоже одинаковый тип.

    /* Доступ к данным в HashMap */

    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10); 
    scores.insert(String::from("yellow"), 50);

    let team_name = String::from("blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);       // Получение значения HashMap по ключу

    // Здесь score будет иметь количество очков, связанное с командой "Blue", результат будет 10. Метод get возвращает Option<&V>; 
    // если для какого-то ключа нет значения в HashMap, get вернёт None. Из-за такого подхода программе следует обрабатывать Option, 
    // вызывая copied для получения Option<i32> вместо Option<&i32>, затем unwrap_or для установки score в ноль, если scores не содержит 
    // данных по этому ключу.

    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("yellow"), 50);

    for (key, value) in &scores {
        println!("{key}: {value}");
    }
    // Перебор HashMap происходит в произвольном порядке

    /* Хеш-карты и владение */

    // Для типов, которые реализуют типаж Copy, например i32, значения копируются в HashMap. Для значений со владением, таких как String, 
    // значения будут перемещены в хеш-карту и она станет владельцем этих значений.

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    
    // Мы не можем использовать переменные field_name и field_value после того, как их значения были перемещены в HashMap вызовом метода insert.
    // Если мы вставим в HashMap ссылки на значения, то они не будут перемещены в HashMap. Значения, на которые указывают ссылки, должны быть 
    // действительными хотя бы до тех пор, пока хеш-карта действительна. 

    /* Обновление данных в HashMap */

    // Хотя количество ключей и значений может увеличиваться в HashMap, каждый ключ может иметь только одно значение, связанное с ним в один момент 
    // времени (обратное утверждение неверно: команды "Blue" и "Yellow" могут хранить в хеш-карте scores одинаковое количество очков, например 10).

    // Когда вы хотите изменить данные в хеш-карте, необходимо решить, как обрабатывать случай, когда ключ уже имеет назначенное значение. 
    // Можно заменить старое значение новым, полностью игнорируя старое. Можно сохранить старое значение и игнорировать новое, или добавлять новое значение, 
    // если только ключ ещё не имел значения. Или можно было бы объединить старое значение и новое значение. Давайте посмотрим, как сделать каждый из вариантов!

    /* Перезапись старых значений */
    // Если мы вставим ключ и значение в HashMap, а затем вставим тот же ключ с новым значением, то старое значение связанное с этим ключом, будет заменено на новое.
    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{:?}", scores);

    /* Вставка значения только в том случае, когда ключ не имеет значения */
    // Обычно проверяют, существует ли конкретный ключ в хеш-карте со значением, а затем предпринимаются следующие действия: если ключ существует в хеш-карте, 
    // существующее значение должно оставаться таким, какое оно есть. Если ключ не существует, то вставляют его и значение для него.

    // Хеш-карты имеют для этого специальный API, называемый entry , который принимает ключ для проверки в качестве входного параметра. Возвращаемое значение 
    // метода entry - это перечисление Entry, с двумя вариантами: первый представляет значение, которое может существовать, а второй говорит о том, что значение 
    // отсутствует. Допустим, мы хотим проверить, имеется ли ключ и связанное с ним значение для команды "Yellow". Если хеш-карта не имеет значения для такого ключа, 
    // то мы хотим вставить значение 50. То же самое мы хотим проделать и для команды "Blue". Используем API entry

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{:?}", scores);

    // Метод or_insert определён в Entry так, чтобы возвращать изменяемую ссылку на соответствующее значение ключа внутри варианта перечисления Entry, 
    // когда этот ключ существует, а если его нет, то вставлять параметр в качестве нового значения этого ключа и возвращать изменяемую ссылку на новое значение. 
    // Эта техника намного чище, чем самостоятельное написание логики и, кроме того, она более безопасна и согласуется с правилами заимствования.

    /* Создание нового значения на основе старого значения */
    // Другим распространённым вариантом использования хеш-карт является поиск значения по ключу, а затем обновление этого значения на основе старого значения. 
    
    // Подсчитываем, сколько раз определённое слово встречается в некотором тексте. Мы используем HashMap со словами в качестве ключей и увеличиваем соответствующее 
    // слову значение, чтобы отслеживать, сколько раз мы встретили это слово. Если мы впервые встретили слово, то сначала вставляем значение 0.

    let text = "hello world wonderful world";
    let mut map = HashMap::new();

    for word in text.split_whitespace() {                   // метод split_whitespace() возвращает итератор со срезами строки
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{:?}", map);
    //Этот код напечатает {"world": 2, "hello": 1, "wonderful": 1}. Если вы увидите, что пары ключ/значение печатаются в другом порядке, 
    // то вспомните, что мы писали в секции "Доступ к данным в HashMap", что итерация по хеш-карте происходит в произвольном порядке.

    // Метод split_whitespace возвращает итератор по срезам строки, разделённых пробелам, для строки text. Метод or_insert возвращает 
    // изменяемую ссылку (&mut V) на значение ключа. Мы сохраняем изменяемую ссылку в переменной count, для этого, чтобы присвоить переменной 
    // значение, необходимо произвести разыменование с помощью звёздочки (*). Изменяемая ссылка удаляется сразу же после выхода из области видимости 
    // цикла for, поэтому все эти изменения безопасны и согласуются с правилами заимствования.

    /* Функция хеширования */
    // По умолчанию HashMap использует функцию хеширования SipHash, которая может противостоять атакам класса отказ в обслуживании, 
    // Denial of Service (DoS) с использованием хеш-таблиц siphash. Это не самый быстрый из возможных алгоритмов хеширования, 
    // в данном случае производительность идёт на компромисс с обеспечением лучшей безопасности. Если после профилирования вашего кода окажется, 
    // что хеш-функция, используемая по умолчанию, очень медленная, вы можете заменить её используя другой hasher. Hasher - это тип, реализующий 
    // трейт BuildHasher.

    //  Вам совсем не обязательно реализовывать свою собственную функцию хеширования; crates.io имеет достаточное количество библиотек, 
    // предоставляющих разные реализации hasher с множеством общих алгоритмов хеширования.
}
