/* 
    Методы похожи на функции: мы объявляем их с помощью ключевого слова fn и имени, 
    они могут иметь параметры и возвращаемое значение, и они содержат код, запускающийся 
    в случае вызова метода. В отличие от функций, методы определяются в контексте структуры 
    (или перечисления, или типаж-объекта, которые мы рассмотрим в Главах 6 и 17 соответственно), 
    и их первым параметром всегда является self, представляющий собой экземпляр структуры, 
    на которой вызывается этот метод. 
*/

// Определение методов
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn width(&self) -> bool {
        self.width > 0
    }


    // Ассоциированные функции, не являющиеся методами, часто используются для конструкторов, 
    // возвращающих новый экземпляр структуры. Их часто называют new, но new не является специальным 
    // именем и не встроена в язык. Например, мы можем предоставить ассоциированную функцию с именем square, 
    // которая будет иметь один параметр размера и использовать его как ширину и высоту, что упростит создание 
    // квадратного Rectangle, вместо того, чтобы указывать одно и то же значение дважды:

    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}

impl Rectangle{
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    println!("{}", rect1.width());
    println!("The area of the rectangle is {} squate pixels", rect1.area());


    /* Где используется оператор `->` ? */

    // В языках C и C++, используются два различных оператора для вызова методов: используется ., 
    // если вызывается метод непосредственно у экземпляра структуры и используется ->, если вызывается 
    // метод у ссылки на объект. Другими словами, если object является ссылкой, то вызовы метода object->something() 
    // и (*object).something() являются аналогичными.

    // Rust не имеет эквивалента оператора ->, наоборот, в Rust есть функциональность называемая автоматическое 
    // обращение по ссылке и разыменование (automatic referencing and dereferencing). Вызов методов является 
    // одним из немногих мест в Rust, в котором есть такое поведение.

    // Вот как это работает: когда вы вызываете метод object.something(), Rust автоматически добавляет &, &mut 
    // или *, таким образом, чтобы object соответствовал сигнатуре метода. Другими словами, это то же самое:

    //     p1.distance(&p2);
    //     (&p1).distance(&p2);

    // Первый пример выглядит намного понятнее. Автоматический вывод ссылки работает потому, что методы имеют 
    // понятного получателя - тип self. Учитывая получателя и имя метода, Rust может точно определить, что в 
    // данном случае делает код: читает ли метод (&self), делает ли изменение (&mut self) или поглощает (self). 
    // Тот факт, что Rust делает заимствование неявным для принимающего метода, в значительной степени способствует 
    // тому, чтобы сделать владение эргономичным на практике.


    /* Методы с несколькими параметрами */

    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };

    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));

    /* Ассоциированные функции */
    // Все функции, определённые в блоке impl, называются ассоциированными функциями, потому что они 
    // ассоциированы с типом, указанным после ключевого слова impl. Мы можем определить ассоциированные 
    // функции, которые не имеют self в качестве первого параметра (и, следовательно, не являются методами), 
    // потому что им не нужен экземпляр типа для работы. Мы уже использовали одну подобную функцию: 
    // функцию String::from, определённую для типа String.

    // Ассоциированные функции, не являющиеся методами, часто используются для конструкторов, 
    // возвращающих новый экземпляр структуры. Их часто называют new, но new не является специальным 
    // именем и не встроена в язык. Например, мы можем предоставить ассоциированную функцию с именем square, 
    // которая будет иметь один параметр размера и использовать его как ширину и высоту, что упростит создание 
    // квадратного Rectangle, вместо того, чтобы указывать одно и то же значение дважды:

    let sq = Rectangle::square(3);
    println!("Square = {:#?}", sq);

    // Ключевые слова Self в возвращаемом типе и в теле функции являются псевдонимами для типа, 
    // указанного после ключевого слова impl, которым в данном случае является Rectangle.

    // Чтобы вызвать эту ассоциированную функцию, мы используем синтаксис :: с именем структуры; 
    // например, let sq = Rectangle::square(3);. Эта функция входит в пространство имён структуры: 
    // синтаксис :: используется как для ассоциированных функций, так и для пространств имён, созданных модулями.
    
    
    /* Несколько блоков impl */

    // Каждая структура может иметь несколько impl.


    /* Итоги */
    // Структуры позволяют создавать собственные типы, которые имеют смысл в вашей предметной области. 
    // Используя структуры, вы храните ассоциированные друг с другом фрагменты данных и даёте название частям данных, 
    // чтобы ваш код был более понятным. Методы позволяют определить поведение, которое имеют экземпляры ваших структур, 
    // а ассоциированные функции позволяют привязать функциональность к вашей структуре, не обращаясь к её экземпляру.

    // Но структуры — не единственный способ создавать собственные типы: давайте обратимся к перечислениям в Rust, 
    // чтобы добавить ещё один инструмент в свой арсенал.
}
