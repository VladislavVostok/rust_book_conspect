fn main() {

    /***********************************/
    /*      ССЫЛКИ И ЗАИМСТВОВАНИЯ     */
    /***********************************/

    // Вместо того чтобы передавать объект и менять владельца, можно передавать ссылку.
    // Ссылка похожа на указатель, в том смысле что передаётся адрес расположения объекта.
    // Ссылка гарантировано указывает на допустимое значение определённого типа в течении всего срока существования этой ссылки.

    // 1 грурпа примеров
    let s1 = String::from("Hello");
    let len = calculate_length(&s1);            // При передаче ссылки мы не передаём владение
    println!("The length of '{}' is {}", s1, len);
    println!("{}", s1);
    println!("{}", s1);
    println!("{}", s1);

    // s                             s1                              heap
    //------|-------|               |----------|-------|            |----------|-------|
    // name | value |               | name     | value |            |   name   | value |
    //------|-------|               |----------|-------|            |----------|-------|
    //  ptr |   ------------------->|  ptr     |   ---------------->|     0    |   h   |
    //------|-------|               |----------|-------|            |----------|-------|
    //                              |  len     |   5   |            |     1    |   e   |
    //                              |----------|-------|            |----------|-------|
    //                              | capacity |   5   |            |     2    |   l   |
    //                              |----------|-------|            |----------|-------|
    //                                                              |     3    |   l   |
    //                                                              |----------|-------|
    //                                                              |     4    |   o   |
    //                                                              |----------|-------|
    // 
    // Обратной операции & (Заимстование или Получение ссылки) есть операция * (разыменование)

    // 2 группа примеров
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}",s);


    let mut st = String::from("hello");
    let r1 = &mut st;
    //let r2 = &mut st;  //  ^^^^^^^ second mutable borrow occurs here (Эта ошибка говорит о том, 
                                    // что код невалиден, потому что мы не можем заимствовать s как изменяемые более одного раза в один момент.)
    //println!("{}, {}", r1, r2);
    println!("r1: {}", r1);

    // Преимущество этого ограничения заключается в том, что Rust может предотвратить гонку данных во время компиляции. 
    // Гонка данных похожа на состояние гонки и происходит, когда возникают следующие три сценария:
    // * Два или больше указателей используют одни и те же данные в одно и то же время,
    // * Минимум один указатель используется для записи данных,
    // * Отсутствуют механизмы для синхронизации доступа к данным.

    // Гонки данных вызывают неопределённое поведение.


    // Можно делать так, получаем в отдельно скоупе ссылку на изменяемый общъект
    let mut str = String::from("hello");
    {
        let r1 = &mut str;
    }       //  Т.к. здесь кончается цикл жизни переменной r1, то мы не заимствуем ссылку на один и тот же объект одновременно
    let r2 = &mut str;



    // Следующий прикол, если мы комбинируем заимствование с изменяемой ссылкой и неизменяемой ссылкой на изменяемый объект, тогда получаем ошибку:
    let mut sss = String::from("hello");
    let r1 = &sss;   // нет проблем
    let r2 = &sss;   // нет проблем
    //let r3 = &mut sss;  // Большая проблема ^^^^^^ mutable borrow occurs here  // У меня ошибку не вывело
    //println!("{}, {}, and {}", r1, r2, r3);

    // У нас также не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение.
    // Мы можем иметь сколько угодно неизменяемы ссылок, т.к. они предоставляются данные для чтения.

    let mut s = String::from("hello");
    let r1 = &s;   // Нет проблем
    let r2 = &s;   // Нет проблем
    println!("{} and {}", r1, r2);

    //Т.к. после прочтения r1 и r2 они не будут использоваться дальше и теперь мы можем объявить изменяемую ссылку
    // https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes
    let r3 = &mut s;   // Нет проблем
    print!("{}", r3);

    // Способность компилятора сообщить, что ссылка больше не используется в точке до конца области видимости, 
    // называется нелексическим временем жизни (сокращённо NLL).

    /***********************************/
    /*        Висячие ссылки           */
    /***********************************/

    /*  
        В языках с указателями легко ошибочно создать висячий указатель — указатель, ссылающийся на место в памяти, 
        которое могло быть передано кому-то другому после освобождения этой части памяти, сохраняя при этом указатель на неё. 
        В Rust, напротив, компилятор гарантирует, что ссылки никогда не будут висячими: если у вас есть ссылка на какие-то данные, 
        компилятор убедится, что данные не выйдут за пределы области видимости до того, как это сделает ссылка на них.
    */

    let reference_to_nothing = dangle();
    println!("{}", reference_to_nothing);

    /*
        Правила работы с ссылками
        Давайте повторим все, что мы обсудили про ссылки:

        * В один момент времени, может существовать либо одна изменяемая ссылка, 
          либо любое количество неизменяемых ссылок,
        * Все ссылки должны быть действительными.
    */

}

// 1 грурпа примеров
fn calculate_length(s: &String) -> usize {      // s есть ссылка типа String
    s.len()
}   // Здесь s выходит за пределы области видимости, т.к. у неё нет права собственности на то к чему относится данная ссылка, то значение не drop. 
    // И нам не нужен возврат значения, чтобы вернуть владение, т.к. s этим объектом не владеет.


fn change(some_string: &mut String){
    some_string.push_str(", world");   // Как переменные неизменяемы по умолчанию, так и ссылки. Нам не разрешено изменять то, на что у нас есть ссылка, нужно их сделать mut.
}

//fn dangle() -> &String {
fn dangle() -> String {
    //          ^ expected named lifetime parameter (Это сообщение об ошибке относится к особенности языка, которую мы ещё не рассмотрели: времени жизни.)

    /*
        Поскольку s создаётся внутри dangle, когда код dangle будет завершён, s будет освобождена. Но мы попытались вернуть ссылку на неё. 
        Это означает, что эта ссылка будет указывать на недопустимую String. Это нехорошо! Rust не позволит нам сделать это.
        Решением будет вернуть непосредственно String
    */
    let s = String::from("hello");
    //&s
    s
}