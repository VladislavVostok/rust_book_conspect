/*
    6.      Перечисления и сопоставление с образцом (Enums and Pattern Matching)
    6.2.    Управляющая конструкция match (The match Control Flow Construct)

    /*
        Механихм управления потоком match позволяет сравнивать значения шаблона и затем выполнять код, аналогией может являться конструктор ветвления if. 
        Шаблоны могут состоять из литеральныъ значений, имён переменных, подстановочныъ знаков и многое другое. Отлично сочетается с перечислениями.
        Сила match заключается в вырадительности шаблонов и в том, чо компилятор проверяет, что все возможные случаи обработаны.
    */
*/


fn main() {
    /* Первая версия */
    println!("{}", value_in_cents(Coin::Nickel));
    println!("{}", value_in_cents_2(Coin::Penny));

    /* Шаблоны, которые привязывают значения */

    // Есть ещё одно полезное качество у веток в выражении match: 
    // они могут привязываться к частям тех значений, которые совпали с шаблоном. 
    // Благодаря этому можно извлекать значения из вариантов перечисления.
    println!("{}", value_in_cents_3(Coin2::Quarter(UsState::Alaska)));

    /* 
        Если мы сделаем вызов функции value_in_cents_3(Coin2::Quarter(UsState::Alaska)), 
        то coin будет иметь значение Coin2::Quarter(UsState::Alaska). Когда мы будем 
        сравнивать это значение с каждой из веток, ни одна из них не будет совпадать, 
        пока мы не достигнем варианта Coin2::Quarter(state). В этот момент state привяжется к 
        значению UsState::Alaska. Затем мы сможем использовать эту привязку в выражении println!, 
        получив таким образом внутреннее значение варианта Quarter перечисления Coin2. 
    */

    /* Сопоставление шаблона для Option<T> */
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    /* Match объемлет все варианты значения */
    // Есть ещё один аспект match, который мы должны обсудить: шаблоны должны покрывать все возможные варианты.
    //let five = Some(5);
    //let six = plus_one_without_none(five);

    /*
        Мы не обработали вариант None, поэтому этот код вызовет дефект в программе. 
        К счастью, Rust знает и умеет ловить такой случай. Если мы попытаемся скомпилировать такой код, мы получим ошибку компиляции:

                error[E0004]: non-exhaustive patterns: `None` not covered
        --> main.rs:121:11
            |
        121 |     match x {
            |           ^ pattern `None` not covered
            |
    */

    /*
        Rust знает, что мы не описали все возможные случаи, и даже знает, какой именно из шаблонов мы упустили! 
        Сопоставления в Rust являются исчерпывающими: мы должны покрыть все возможные варианты, чтобы код был корректным. 
        Особенно в случае Option<T>, когда Rust не даёт нам забыть обработать явным образом значение None, тем самым он 
        защищает нас от предположения, что у нас есть значение, в то время как у нас может быть и null, что делает невозможным совершить ошибку.
    */

    
    /* Универсальные шаблоны и заполнитель _ */
    // Используя перечисления, мы также можем выполнять специальные действия для нескольких определённых значений, 
    // а для всех остальных значений выполнять одно действие по умолчанию.
    /*
        Представьте, что мы реализуем игру, в которой при выпадении 3 игрок не двигается, а получает новую модную шляпу. 
        Если выпадает 7, игрок теряет шляпу. При всех остальных значениях ваш игрок перемещается на столько-то мест на игровом поле. 
        Вот match, реализующий эту логику, в котором результат броска костей жёстко закодирован, а не является случайным значением, 
        а вся остальная логика представлена функциями без тел, поскольку их реализация не входит в рамки данного примера
    */

    let dice_roll = 9;
    match dice_roll {
        // Для первых двух веток шаблона применяются литеральные значения 3 и 7.
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        // Для последней ветки шаблона, применяется переменная, которая охватывает все остальные результаты. 
        // Переменную dice_roll этот патерн определяет в other и передаёт её в качестве аргумента в функцию
        other => move_player(other)
    }

    /*
        В Rust также есть шаблон, который можно использовать, когда мы не хотим использовать значение в универсальном шаблоне: _, 
        который является специальным шаблоном, который соответствует любому значению и не привязывается к этому значению. Это говорит Rust, 
        что мы не собираемся использовать это значение, поэтому Rust не будет предупреждать нас о неиспользуемой переменной.
    */

    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),
    }

    /*
        Если мы изменим правила игры ещё раз, чтобы в ваш ход не происходило ничего другого, если вы бросаете не 3 или 7, мы можем выразить это, 
        используя единичное значение (пустой тип кортежа) в качестве кода, который идёт вместе с веткой _:
    */

    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (),
    }
}

/* Первая версия */
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

// Если кода для обработки болеше, нужны фигурные скобки.

fn value_in_cents_2(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

/* Шаблоны, которые привязывают значения */
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabaam,
    Alaska,
}

enum Coin2 {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents_3(coin: Coin2) -> u8 {
    match coin {
        Coin2::Penny => 1,
        Coin2::Nickel => 5,
        Coin2::Dime => 10,
        Coin2::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

/* Сопоставление шаблона для Option<T> */
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,         // если x None тогда ветка возвращает None
        Some(i) => Some(i+1), // если x (в данном случае это Some(5)) соответствует шаблону Some(i), тогда i привязывается к значению 5 и к нему прибавляем 1,
                              // В случае патерна Some(i) вернутся объект Some(6) типа Option<i32>  
    }
    /* match возвращает сам значения после оператора => */
}


/* Match объемлет все варианты значения */
// fn plus_one_without_none(x: Option<i32>) -> Option<i32> {
//     match x {
//         Some(i) => Some(i+1), 
//     }
// }


/* Универсальные шаблоны и заполнитель _ */
fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}

fn reroll() {}